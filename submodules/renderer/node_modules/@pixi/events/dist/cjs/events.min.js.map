{"version":3,"file":"events.min.js","sources":["../../../../node_modules/tslib/tslib.es6.js","../../src/FederatedEvent.ts","../../src/FederatedMouseEvent.ts","../../src/FederatedPointerEvent.ts","../../src/FederatedWheelEvent.ts","../../src/EventBoundary.ts","../../src/EventSystem.ts","../../src/FederatedEventTarget.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Point } from '@pixi/math';\nimport type { EventBoundary } from './EventBoundary';\nimport type { FederatedEventTarget } from './FederatedEventTarget';\n\n/**\n * An DOM-compatible synthetic event implementation that is \"forwarded\" on behalf of an original\n * FederatedEvent or native {@link https://dom.spec.whatwg.org/#event Event}.\n * @memberof PIXI\n * @typeParam N - The type of native event held.\n */\nexport class FederatedEvent<N extends UIEvent = UIEvent> implements UIEvent\n{\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    public bubbles = true;\n\n    /** @deprecated */\n    public cancelBubble = true;\n\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    public readonly cancelable = false;\n\n    /**\n     * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    public readonly composed = false;\n\n    /** The listeners of the event target that are being notified. */\n    public currentTarget: FederatedEventTarget;\n\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    public defaultPrevented = false;\n\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    public eventPhase = FederatedEvent.prototype.NONE;\n\n    /** Flags whether this is a user-trusted event */\n    public isTrusted: boolean;\n\n    /** @deprecated */\n    public returnValue: boolean;\n\n    /** @deprecated */\n    public srcElement: EventTarget;\n\n    /** The event target that this will be dispatched to. */\n    public target: FederatedEventTarget;\n\n    /** The timestamp of when the event was created. */\n    public timeStamp: number;\n\n    /** The type of event, e.g. {@code \"mouseup\"}. */\n    public type: string;\n\n    /** The native event that caused the foremost original event. */\n    public nativeEvent: N;\n\n    /** The original event that caused this event, if any. */\n    public originalEvent: FederatedEvent<N>;\n\n    /** Flags whether propagation was stopped. */\n    public propagationStopped = false;\n\n    /** Flags whether propagation was immediately stopped. */\n    public propagationImmediatelyStopped = false;\n\n    /** The composed path of the event's propagation. The {@code target} is at the end. */\n    public path: FederatedEventTarget[];\n\n    /** The {@link EventBoundary} that manages this event. Null for root events. */\n    public readonly manager: EventBoundary;\n\n    /** Event-specific detail */\n    public detail: number;\n\n    /** The global Window object. */\n    public view: WindowProxy;\n\n    /**\n     * Not supported.\n     * @deprecated\n     */\n    public which: number;\n\n    /** The coordinates of the evnet relative to the nearest DOM layer. This is a non-standard property. */\n    public layer: Point = new Point();\n\n    /** @readonly */\n    get layerX(): number { return this.layer.x; }\n\n    /** @readonly */\n    get layerY(): number { return this.layer.y; }\n\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    public page: Point = new Point();\n\n    /** @readonly */\n    get pageX(): number { return this.page.x; }\n\n    /** @readonly */\n    get pageY(): number { return this.page.y; }\n\n    /**\n     * @param manager - The event boundary which manages this event. Propagation can only occur\n     *  within the boundary's jurisdiction.\n     */\n    constructor(manager: EventBoundary)\n    {\n        this.manager = manager;\n    }\n\n    /**\n     * Fallback for the deprecated {@link PIXI.InteractionEvent.data}.\n     * @deprecated\n     */\n    get data(): this\n    {\n        return this;\n    }\n\n    /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */\n    composedPath(): FederatedEventTarget[]\n    {\n        // Find the propagation path if it isn't cached or if the target has changed since since\n        // the last evaluation.\n        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target))\n        {\n            this.path = this.target ? this.manager.propagationPath(this.target) : [];\n        }\n\n        return this.path;\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.\n     * @deprecated\n     * @param _type\n     * @param _bubbles\n     * @param _cancelable\n     */\n    initEvent(_type: string, _bubbles?: boolean, _cancelable?: boolean): void\n    {\n        throw new Error('initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.\n     * @deprecated\n     * @param _typeArg\n     * @param _bubblesArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     */\n    initUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window | null,\n        _detailArg?: number): void\n    {\n        throw new Error('initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /** Prevent default behavior of PixiJS and the user agent. */\n    preventDefault(): void\n    {\n        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable)\n        {\n            this.nativeEvent.preventDefault();\n        }\n\n        this.defaultPrevented = true;\n    }\n\n    /**\n     * Stop this event from propagating to any addition listeners, including on the\n     * {@link FederatedEventTarget.currentTarget currentTarget} and also the following\n     * event targets on the propagation path.\n     */\n    stopImmediatePropagation(): void\n    {\n        this.propagationImmediatelyStopped = true;\n    }\n\n    /**\n     * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners\n     * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.\n     */\n    stopPropagation(): void\n    {\n        this.propagationStopped = true;\n    }\n\n    AT_TARGET = 1;\n    BUBBLING_PHASE = 2;\n    CAPTURING_PHASE = 3;\n    NONE = 0;\n}\n","import { FederatedEvent } from './FederatedEvent';\nimport { Point } from '@pixi/math';\n\n/**\n * A {@link PIXI.FederatedEvent} for mouse events.\n * @memberof PIXI\n */\nexport class FederatedMouseEvent extends FederatedEvent<\nMouseEvent | PointerEvent | TouchEvent\n> implements MouseEvent\n{\n    /** Whether the \"alt\" key was pressed when this mouse event occurred. */\n    altKey: boolean;\n\n    /** The specific button that was pressed in this mouse event. */\n    button: number;\n\n    /** The button depressed when this event occurred. */\n    buttons: number;\n\n    /** Whether the \"control\" key was pressed when this mouse event occurred. */\n    ctrlKey: boolean;\n\n    /** Whether the \"meta\" key was pressed when this mouse event occurred. */\n    metaKey: boolean;\n\n    /** This is currently not implemented in the Federated Events API. */\n    relatedTarget: EventTarget;\n\n    /** Whether the \"shift\" key was pressed when this mouse event occurred. */\n    shiftKey: boolean;\n\n    /** The coordinates of the mouse event relative to the canvas. */\n    public client: Point = new Point();\n\n    /** @readonly */\n    public get clientX(): number { return this.client.x; }\n\n    /** @readonly */\n    public get clientY(): number { return this.client.y; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n     * @readonly\n     */\n    get x(): number { return this.clientX; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n     * @readonly\n     */\n    get y(): number { return this.clientY; }\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    public movement: Point = new Point();\n\n    /** @readonly */\n    get movementX(): number { return this.movement.x; }\n\n    /** @readonly */\n    get movementY(): number { return this.movement.y; }\n\n    /**\n     * The offset of the pointer coordinates w.r.t. target DisplayObject in world space. This is\n     * not supported at the moment.\n     */\n    public offset: Point = new Point();\n\n    /** @readonly */\n    get offsetX(): number { return this.offset.x; }\n\n    /** @readonly */\n    get offsetY(): number { return this.offset.y; }\n\n    /** The pointer coordinates in world space. */\n    public global: Point = new Point();\n\n    /** @readonly */\n    get globalX(): number { return this.global.x; }\n\n    /** @readonly */\n    get globalY(): number { return this.global.y; }\n\n    /**\n     * The pointer coordinates in the renderer's {@link PIXI.Renderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    public screen: Point = new Point();\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.\n     * @readonly\n     */\n    get screenX(): number { return this.screen.x; }\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.\n     * @readonly\n     */\n    get screenY(): number { return this.screen.y; }\n\n    /**\n     * Whether the modifier key was pressed when this event natively occurred.\n     * @param key - The modifier key.\n     */\n    getModifierState(key: string): boolean\n    {\n        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n\n    /**\n     * Not supported.\n     * @param _typeArg\n     * @param _canBubbleArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     * @param _screenXArg\n     * @param _screenYArg\n     * @param _clientXArg\n     * @param _clientYArg\n     * @param _ctrlKeyArg\n     * @param _altKeyArg\n     * @param _shiftKeyArg\n     * @param _metaKeyArg\n     * @param _buttonArg\n     * @param _relatedTargetArg\n     * @deprecated\n     */\n    // eslint-disable-next-line max-params\n    initMouseEvent(\n        _typeArg: string,\n        _canBubbleArg: boolean,\n        _cancelableArg: boolean,\n        _viewArg: Window,\n        _detailArg: number,\n        _screenXArg: number,\n        _screenYArg: number,\n        _clientXArg: number,\n        _clientYArg: number,\n        _ctrlKeyArg: boolean,\n        _altKeyArg: boolean,\n        _shiftKeyArg: boolean,\n        _metaKeyArg: boolean,\n        _buttonArg: number,\n        _relatedTargetArg: EventTarget\n    ): void\n    {\n        throw new Error('Method not implemented.');\n    }\n}\n","import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A {@link PIXI.FederatedEvent} for pointer events.\n * @memberof PIXI\n */\nexport class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent\n{\n    /**\n     * The unique identifier of the pointer.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}\n     */\n    public pointerId: number;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    public width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    public height = 0;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    public isPrimary = false;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */\n    public pointerType: string;\n\n    /**\n     * Pressure applied by the pointing device during the event.\n     *s\n     * A Touch's force property will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */\n    public pressure: number;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public tangentialPressure: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     */\n    public tiltX: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     */\n    public tiltY: number;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public twist: number;\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    // Only included for completeness for now\n    getCoalescedEvents(): PointerEvent[]\n    {\n        if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove')\n        {\n            return [this];\n        }\n\n        return [];\n    }\n\n    // Only included for completeness for now\n    getPredictedEvents(): PointerEvent[]\n    {\n        throw new Error('getPredictedEvents is not supported!');\n    }\n}\n","import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A {@link PIXI.FederatedEvent} for wheel events.\n * @memberof PIXI\n */\nexport class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent\n{\n    /**\n     * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n     * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n     */\n    deltaMode: number;\n\n    /** Horizontal scroll amount */\n    deltaX: number;\n\n    /** Vertical scroll amount */\n    deltaY: number;\n\n    /** z-axis scroll amount. */\n    deltaZ: number;\n\n    /** Units specified in lines. */\n    DOM_DELTA_LINE = 0;\n\n    /** Units specified in pages. */\n    DOM_DELTA_PAGE = 1;\n\n    /** Units specified in pixels. */\n    DOM_DELTA_PIXEL = 2;\n}\n","import { EventEmitter } from '@pixi/utils';\nimport { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\nimport { Point } from '@pixi/math';\n\nimport type { Cursor, FederatedEventTarget } from './FederatedEventTarget';\nimport type { DisplayObject } from '@pixi/display';\nimport type { FederatedEvent } from './FederatedEvent';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * The tracking data for each pointer held in the state of an {@link PIXI.EventBoundary}.\n *\n * ```ts\n * pressTargetsByButton: {\n *      [id: number]: FederatedEventTarget[];\n * };\n * clicksByButton: {\n *     [id: number]: {\n *         clickCount: number;\n *         target: FederatedEventTarget;\n *         timeStamp: number;\n *     }\n * };\n * overTargets: FederatedEventTarget[];\n * ```\n * @typedef {object} TrackingData\n * @property {Record.<number, PIXI.FederatedEventTarget>} pressTargetsByButton - The pressed display objects'\n *  propagation paths by each button of the pointer.\n * @property {Record.<number, object>} clicksByButton - Holds clicking data for each button of the pointer.\n * @property {PIXI.DisplayObject[]} overTargets - The DisplayObject propagation path over which the pointer is hovering.\n * @memberof PIXI\n */\ntype TrackingData = {\n    pressTargetsByButton: {\n        [id: number]: FederatedEventTarget[];\n    };\n    clicksByButton: {\n        [id: number]: {\n            clickCount: number;\n            target: FederatedEventTarget;\n            timeStamp: number;\n        }\n    };\n    overTargets: FederatedEventTarget[];\n};\n\n/**\n * Internal storage of event listeners in EventEmitter.\n * @ignore\n */\ntype EmitterListeners = Record<string,\n| Array<{ fn(...args: any[]): any, context: any }>\n| { fn(...args: any[]): any, context: any }\n>;\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link PIXI.EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link PIXI.EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link PIXI.FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from '@pixi/display';\n * import { EventBoundary } from '@pixi/events';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends DisplayObject\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @memberof PIXI\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     *\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: DisplayObject;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: EventEmitter = new EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | string;\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all DisplayObjects.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link PIXI.EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see PIXI.EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see PIXI.EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see PIXI.EventBoundary#allocateEvent\n     * @see PIXI.EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: DisplayObject)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link PIXI.EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link PIXI.EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e\n     * @param type\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n        }\n    }\n\n    /**\n     * Finds the DisplayObject that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x\n     * @param y\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): DisplayObject\n    {\n        const invertedPath = this.hitTestRecursive(\n            this.rootTarget,\n            this.rootTarget.interactive,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target {@code e.target}.\n     * @param e - The event to propagate.\n     * @param type\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event {@link e} to all display objects. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `pointermove` legacy mode.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param target\n     */\n    public all(e: FederatedEvent, type?: string, target: FederatedEventTarget = this.rootTarget): void\n    {\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const children = target.children;\n\n        if (children)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this.all(e, type, children[i]);\n            }\n        }\n\n        e.currentTarget = target;\n        this.notifyTarget(e, type);\n    }\n\n    /**\n     * Finds the propagation path from {@link PIXI.EventBoundary.rootTarget rootTarget} to the passed\n     * {@code target}. The last element in the path is {@code target}.\n     * @param target\n     */\n    public propagationPath(target: FederatedEventTarget): FederatedEventTarget[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The DisplayObject that is to be hit tested.\n     * @param interactive - Flags whether `currentTarget` or one of its parents are interactive.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the display object.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: DisplayObject,\n        interactive: boolean,\n        location: Point,\n        testFn: (object: DisplayObject, pt: Point) => boolean,\n        pruneFn?: (object: DisplayObject, pt: Point) => boolean,\n    ): DisplayObject[]\n    {\n        if (!currentTarget || !currentTarget.visible)\n        {\n            return null;\n        }\n\n        // Attempt to prune this DisplayObject and its subtree as an optimization.\n        if (pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as DisplayObject;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    interactive || child.interactive,\n                    location,\n                    testFn,\n                    pruneFn,\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    if (nestedHit.length > 0 || currentTarget.interactive)\n                    {\n                        nestedHit.push(currentTarget);\n                    }\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        // Finally, hit test this DisplayObject itself.\n        if (interactive && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return currentTarget.interactive ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Checks whether the display object or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link PIXI.DisplayObject.hitArea hitArea}\n     * and {@link PIXI.DisplayObject._mask} for pruning.\n     * @param displayObject\n     * @param location\n     */\n    protected hitPruneFn(displayObject: DisplayObject, location: Point): boolean\n    {\n        if (displayObject.hitArea)\n        {\n            displayObject.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (displayObject._mask)\n        {\n            const maskObject = ((displayObject._mask as any).isMaskData\n                ? (displayObject._mask as any).maskObject : displayObject._mask);\n\n            if (maskObject && !maskObject.containsPoint?.(location))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the display object passes hit testing for the given location.\n     * @param displayObject\n     * @param location\n     * @returns - Whether `displayObject` passes hit testing for `location`.\n     */\n    protected hitTestFn(displayObject: DisplayObject, location: Point): boolean\n    {\n        // If the display object failed pruning with a hitArea, then it must pass it.\n        if (displayObject.hitArea)\n        {\n            return true;\n        }\n\n        if ((displayObject as any).containsPoint)\n        {\n            return (displayObject as any).containsPoint(location) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     * @param e - The event passed to the target.\n     * @param type\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        type = type ?? e.type;\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this.notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this.notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered DisplayObject is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const propagationMethod = this.moveOnAll ? 'all' : 'dispatchEvent';\n\n        // Then pointermove\n        this[propagationMethod](e, 'pointermove');\n\n        if (e.pointerType === 'touch') this[propagationMethod](e, 'touchmove');\n\n        if (isMouse)\n        {\n            this[propagationMethod](e, 'mousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`, and `click`/`pointertap` events,\n     * in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                this.dispatchEvent(clickEvent, 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the {@code EventBoundary}'s\n     * root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            console.warn('EventBoundary cannot map a non-wheel event as a wheel event');\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: FederatedEventTarget[]): FederatedEventTarget\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The {@code originalEvent} for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: FederatedEventTarget\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target ?? this.hitTest(event.global.x, event.global.y) as FederatedEventTarget;\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose {@code originalEvent} is {@code from}.\n     *\n     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event {@code from}, with an optional {@code type} override.\n     *\n     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link PIXI.FederatedWheelEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from\n     * @param to\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link PIXI.FederatedPointerEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from\n     * @param to\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link PIXI.FederatedMouseEvent} data from {@code from} to {@code to}.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + global\n     * @param from\n     * @param to\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n\n        to.screen.copyFrom(from.screen);\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link PIXI.FederatedEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link PIXI.EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n\n        if ('fn' in listeners)\n        {\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n\n/**\n * Fired when a mouse button (usually a mouse left-button) is pressed on the display.\n * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mousedown\n * @param {PIXI.FederatedPointerEvent} event - The mousedown event.\n */\n\n/**\n * Capture phase equivalent of {@code mousedown}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mousedowncapture\n * @param {PIXI.FederatedPointerEvent} event - The capture phase mousedown.\n */\n\n/**\n * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightdown\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code rightdown}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightdowncapture\n * @param {PIXI.FederatedPointerEvent} event - The rightdowncapture event.\n */\n\n/**\n * Fired when a pointer device button (usually a mouse left-button) is released over the display\n * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseup\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mouseup}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseupcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device secondary button (usually a mouse right-button) is released\n * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightup\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code rightup}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightupcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * A {@code click} event fires after the {@code pointerdown} and {@code pointerup} events, in that\n * order. If the mouse is moved over another DisplayObject after the {@code pointerdown} event, the\n * {@code click} event is fired on the most specific common ancestor of the two target DisplayObjects.\n *\n * The {@code detail} property of the event is the number of clicks that occurred within a 200ms\n * window of each other upto the current click. For example, it will be {@code 2} for a double click.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#click\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code click}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#clickcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This event follows the semantics of {@code click}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightclick\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code rightclick}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightclickcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button (usually a mouse left-button) is released outside the\n * display object that initially registered a\n * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This event is specific to the Federated Events API. It does not have a capture phase, unlike most of the\n * other events. It only bubbles to the most specific ancestor of the targets of the corresponding {@code pointerdown}\n * and {@code pointerup} events, i.e. the target of the {@code click} event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseupoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mouseupoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseupoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device secondary button (usually a mouse right-button) is released\n * outside the display object that initially registered a\n * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightupoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code rightupoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightupoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device (usually a mouse) is moved while over the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mousemove\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mousemove}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mousemovecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device (usually a mouse) is moved onto the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseover\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mouseover}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseovercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the mouse pointer is moved over a DisplayObject and its descendant's hit testing boundaries.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseenter\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mouseenter}\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseentercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device (usually a mouse) is moved off the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This may be fired on a DisplayObject that was removed from the scene graph immediately after\n * a {@code mouseover} event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseout\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mouseout}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseoutcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the mouse pointer exits a DisplayObject and its descendants.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseleave\n * @param {PIXI.FederatedPointerEvent} event\n */\n\n/**\n * Capture phase equivalent of {@code mouseleave}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseleavecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button is pressed on the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerdown\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerdown}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerdowncapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button is released over the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerup\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerup}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerupcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the operating system cancels a pointer event.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointercancel\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointercancel}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointercancelcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button is pressed and released on the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointertap\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointertap}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointertapcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button is released outside the display object that initially\n * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This event is specific to the Federated Events API. It does not have a capture phase, unlike most of the\n * other events. It only bubbles to the most specific ancestor of the targets of the corresponding {@code pointerdown}\n * and {@code pointerup} events, i.e. the target of the {@code click} event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerupoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerupoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerupoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device is moved while over the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointermove\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointermove}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointermovecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device is moved onto the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerover\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerover}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerovercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the pointer is moved over a DisplayObject and its descendant's hit testing boundaries.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerenter\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerenter}\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerentercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device is moved off the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerout\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerout}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointeroutcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the pointer leaves the hit testing boundaries of a DisplayObject and its descendants.\n *\n * This event notifies only the target and does not bubble.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerleave\n * @param {PIXI.FederatedPointerEvent} event - The `pointerleave` event.\n */\n\n/**\n * Capture phase equivalent of {@code pointerleave}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerleavecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a touch point is placed on the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchstart\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code touchstart}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchstartcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a touch point is removed from the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchend\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code touchend}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchendcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the operating system cancels a touch.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchcancel\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code touchcancel}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchcancelcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a touch point is placed and removed from the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#tap\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code tap}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#tapcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a touch point is removed outside of the display object that initially\n * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchendoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code touchendoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchendoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a touch point is moved along the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchmove\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code touchmove}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchmovecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a the user scrolls with the mouse cursor over a DisplayObject.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#wheel\n * @type {PIXI.FederatedWheelEvent}\n */\n\n/**\n * Capture phase equivalent of {@code wheel}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#wheelcapture\n * @type {PIXI.FederatedWheelEvent}\n */\n","import { EventBoundary } from './EventBoundary';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { IRenderableObject } from '@pixi/core';\nimport type { DisplayObject } from '@pixi/display';\nimport type { IPointData } from '@pixi/math';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\ninterface Renderer\n{\n    _lastObjectRendered: IRenderableObject;\n    view: HTMLCanvasElement;\n    resolution: number;\n    plugins: Record<string, any>;\n}\n\n/**\n * The system for handling UI events.\n *\n * ### Setup\n *\n * As for PixiJS v6.x, `@pixi/events` is an opt-in package, so you need to import it first.\n *\n * #### NPM Install\n *\n * ```sh\n * npm install @pixi/events@v6.x\n * ```\n *\n * There is no default export. The correct way to import EventSystem is:\n *\n * ```js\n * import { Application, Renderer } from 'pixi.js';\n * import { EventSystem } from '@pixi/events';\n *\n * // Disable interaction plugin (for PixiJS v6.x)\n * delete Renderer.__plugins.interaction;\n *\n * const app = new Application();\n * app.renderer.addSystem(EventSystem, 'events');\n * ```\n *\n * #### CDN Install\n *\n * Via jsDelivr:\n *\n * ```html\n * <script src=\"https://cdn.jsdelivr.net/npm/@pixi/events@6.x/dist/browser/events.min.js\"></script>\n * ```\n *\n * Or via unpkg:\n *\n * ```html\n * <script src=\"https://unpkg.com/@pixi/events@6.x/dist/browser/events.min.js\"></script>\n * ```\n *\n * Then install the EventSystem:\n *\n * ```js\n * // Disable interaction plugin (for PixiJS v6.x)\n * delete PIXI.Renderer.__plugins.interaction;\n *\n * const app = new PIXI.Application();\n * app.renderer.addSystem(PIXI.EventSystem, 'events');\n * ```\n *\n * _Note: The version of `@pixi/events` should be the same as the version of `pixi.js` you are using._\n * @memberof PIXI\n */\nexport class EventSystem\n{\n    /**\n     * The {@link PIXI.EventBoundary} for the stage.\n     *\n     * The {@link PIXI.EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed DisplayObjects).\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for {@code domElement},\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object<string, string | ((mode: string) => void) | CSSStyleDeclaration>}\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link PIXI.Renderer#view view}.\n     */\n    public domElement: HTMLElement;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    private currentCursor: string;\n    private rootPointerEvent: FederatedPointerEvent;\n    private rootWheelEvent: FederatedWheelEvent;\n    private eventsAdded: boolean;\n\n    /**\n     * @param {PIXI.Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        if (renderer.plugins.interaction)\n        {\n            throw new Error('EventSystem cannot initialize with the InteractionManager installed!');\n        }\n\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n\n        this.autoPreventDefault = true;\n        this.eventsAdded = false;\n\n        this.rootPointerEvent = new FederatedPointerEvent(null);\n        this.rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n        this.domElement = renderer.view;\n\n        this.onPointerDown = this.onPointerDown.bind(this);\n        this.onPointerMove = this.onPointerMove.bind(this);\n        this.onPointerUp = this.onPointerUp.bind(this);\n        this.onPointerOverOut = this.onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n\n        this.setTargetElement(this.domElement);\n        this.resolution = this.renderer.resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    destroy(): void\n    {\n        this.setTargetElement(null);\n        this.renderer = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * @param mode - cursor mode, a key from the cursorStyles dictionary\n     */\n    public setCursor(mode: string): void\n    {\n        mode = mode || 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this.currentCursor === mode)\n        {\n            return;\n        }\n        this.currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * Event handler for pointer down events on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer._lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        const events = this.normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer._lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer._lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer._lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer._lastObjectRendered as DisplayObject;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link PIXI.EventSystem#domElement domElement} and binds event listeners.\n     *\n     * To deregister the current DOM element without setting a new one, pass {@code null}.\n     * @param element - The new DOM element.\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this.removeEvents();\n        this.domElement = element;\n        this.addEvents();\n    }\n\n    /** Register event listeners on {@link PIXI.Renderer#domElement this.domElement}. */\n    private addEvents(): void\n    {\n        if (this.eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if ((globalThis.navigator as any).msPointerEnabled)\n        {\n            style.msContentZooming = 'none';\n            style.msTouchAction = 'none';\n        }\n        else if (this.supportsPointerEvents)\n        {\n            style.touchAction = 'none';\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this.onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this.onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this.onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this.onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this.onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this.onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this.onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this.onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this.onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this.onPointerUp, true);\n        }\n\n        // Always look directly for touch events so that we can provide original data\n        // In a future version we should change this to being just a fallback and rely solely on\n        // PointerEvents whenever available\n        if (this.supportsTouchEvents)\n        {\n            this.domElement.addEventListener('touchstart', this.onPointerDown, true);\n            // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n            this.domElement.addEventListener('touchend', this.onPointerUp, true);\n            this.domElement.addEventListener('touchmove', this.onPointerMove, true);\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this.eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link PIXI.EventSystem#domElement this.domElement}. */\n    private removeEvents(): void\n    {\n        if (!this.eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if ((globalThis.navigator as any).msPointerEnabled)\n        {\n            style.msContentZooming = '';\n            style.msTouchAction = '';\n        }\n        else if (this.supportsPointerEvents)\n        {\n            style.touchAction = '';\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this.onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this.onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this.onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this.onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this.onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this.onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this.onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this.onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this.onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this.onPointerUp, true);\n        }\n\n        if (this.supportsTouchEvents)\n        {\n            this.domElement.removeEventListener('touchstart', this.onPointerDown, true);\n            // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n            this.domElement.removeEventListener('touchend', this.onPointerUp, true);\n            this.domElement.removeEventListener('touchmove', this.onPointerMove, true);\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this.eventsAdded = false;\n    }\n\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     * @param  {PIXI.IPointData} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n    public mapPositionToPoint(point: IPointData, x: number, y: number): void\n    {\n        let rect;\n\n        // IE 11 fix\n        if (!this.domElement.parentElement)\n        {\n            rect = {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n        }\n        else\n        {\n            rect = this.domElement.getBoundingClientRect();\n        }\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link PIXI.FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this.rootWheelEvent;\n\n        this.transferMouseData(event, nativeEvent);\n\n        event.deltaMode = nativeEvent.deltaMode;\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the {@code nativeEvent} into a federateed {@code FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this.transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n\ninterface PixiTouch extends Touch\n{\n    button: number;\n    buttons: number;\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    layerX: number;\n    layerY: number;\n    offsetX: number;\n    offsetY: number;\n    isNormalized: boolean;\n    type: string;\n}\n","import { DisplayObject } from '@pixi/display';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type { EventEmitter } from '@pixi/utils';\n\nexport type Cursor = 'auto'\n| 'default'\n| 'none'\n| 'context-menu'\n| 'help'\n| 'pointer'\n| 'progress'\n| 'wait'\n| 'cell'\n| 'crosshair'\n| 'text'\n| 'vertical-text'\n| 'alias'\n| 'copy'\n| 'move'\n| 'no-drop'\n| 'not-allowed'\n| 'e-resize'\n| 'n-resize'\n| 'ne-resize'\n| 'nw-resize'\n| 's-resize'\n| 'se-resize'\n| 'sw-resize'\n| 'w-resize'\n| 'ns-resize'\n| 'ew-resize'\n| 'nesw-resize'\n| 'col-resize'\n| 'nwse-resize'\n| 'row-resize'\n| 'all-scroll'\n| 'zoom-in'\n| 'zoom-out'\n| 'grab'\n| 'grabbing';\n\n// @ignore - This is documented elsewhere.\nexport interface IHitArea\n{\n    contains(x: number, y: number): boolean;\n}\n\n/**\n * Describes the shape for a {@link FederatedEvent}'s' `eventTarget`.\n * @memberof PIXI\n */\nexport interface FederatedEventTarget extends EventEmitter, EventTarget\n{\n    /** The cursor preferred when the mouse pointer is hovering over. */\n    cursor: Cursor | string;\n\n    /** The parent of this event target. */\n    readonly parent?: FederatedEventTarget;\n\n    /** The children of this event target. */\n    readonly children?: ReadonlyArray<FederatedEventTarget>;\n\n    /** Whether this event target should fire UI events. */\n    interactive: boolean;\n\n    /** Whether this event target has any children that need UI events. This can be used optimize event propagation. */\n    interactiveChildren: boolean;\n\n    /** The hit-area specifies the area for which pointer events should be captured by this event target. */\n    hitArea: IHitArea | null;\n}\n\nexport const FederatedDisplayObject: Omit<\nFederatedEventTarget,\n'parent' | 'children' | keyof EventEmitter | 'cursor'\n> = {\n    /**\n     * Enable interaction events for the DisplayObject. Touch, pointer and mouse\n     * events will not be emitted unless `interactive` is set to `true`.\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.on('tap', (event) => {\n     *    //handle event\n     * });\n     * @memberof PIXI.DisplayObject#\n     */\n    interactive: false,\n\n    /**\n     * Determines if the children to the displayObject can be clicked/touched\n     * Setting this to false allows PixiJS to bypass a recursive `hitTest` function\n     * @memberof PIXI.Container#\n     */\n    interactiveChildren: true,\n\n    /**\n     * Interaction shape. Children will be hit first, then this shape will be checked.\n     * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);\n     * @member {PIXI.IHitArea}\n     * @memberof PIXI.DisplayObject#\n     */\n    hitArea: null,\n\n    /**\n     * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n     * seeks to be compatible with the DOM's `addEventListener` with support for options.\n     * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.\n     * @memberof PIXI.DisplayObject\n     * @param type - The type of event to listen to.\n     * @param listener - The listener callback or object.\n     * @param options - Listener options, used for capture phase.\n     * @example\n     * // Tell the user whether they did a single, double, triple, or nth click.\n     * button.addEventListener('click', {\n     *   handleEvent(e): {\n     *     let prefix;\n     *\n     *     switch (e.detail) {\n     *       case 1: prefix = 'single'; break;\n     *       case 2: prefix = 'double'; break;\n     *       case 3: prefix = 'triple'; break;\n     *       default: prefix = e.detail + 'th'; break;\n     *     }\n     *\n     *     console.log('That was a ' + prefix + 'click');\n     *   }\n     * });\n     *\n     * // But skip the first click!\n     * button.parent.addEventListener('click', function blockClickOnce(e) {\n     *   e.stopImmediatePropagation();\n     *   button.parent.removeEventListener('click', blockClickOnce, true);\n     * }, {\n     *   capture: true,\n     * })\n     */\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n            || (typeof options === 'object' && options.capture);\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        listener = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        (this as unknown as EventEmitter).on(type, listener, context);\n    },\n\n    /**\n     * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n     * seeks to be compatible with the DOM's `removeEventListener` with support for options.\n     * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.\n     * @memberof PIXI.DisplayObject\n     * @param type - The type of event the listener is bound to.\n     * @param listener - The listener callback or object.\n     * @param options - The original listener options. This is required to deregister a capture phase listener.\n     */\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n            || (typeof options === 'object' && options.capture);\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        listener = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        (this as unknown as EventEmitter).off(type, listener, context);\n    },\n\n    /**\n     * Dispatch the event on this {@link PIXI.DisplayObject} using the event's {@link PIXI.EventBoundary}.\n     *\n     * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n     *\n     * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.\n     * @memberof PIXI.DisplayObject\n     * @param e - The event to dispatch.\n     * @returns Whether the {@link PIXI.FederatedEvent.preventDefault preventDefault}() method was not invoked.\n     * @example\n     * // Reuse a click event!\n     * button.dispatchEvent(clickEvent);\n     */\n    dispatchEvent(e: Event): boolean\n    {\n        if (!(e instanceof FederatedEvent))\n        {\n            throw new Error('DisplayObject cannot propagate events outside of the Federated Events API');\n        }\n\n        e.defaultPrevented = false;\n        e.path = null;\n        e.target = this as FederatedEventTarget;\n        e.manager.dispatchEvent(e);\n\n        return !e.defaultPrevented;\n    }\n};\n\nDisplayObject.mixin(FederatedDisplayObject);\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","FederatedEvent","manager","bubbles","cancelBubble","cancelable","composed","defaultPrevented","eventPhase","NONE","propagationStopped","propagationImmediatelyStopped","layer","Point","page","AT_TARGET","BUBBLING_PHASE","CAPTURING_PHASE","defineProperty","x","y","get","composedPath","path","length","target","propagationPath","initEvent","_type","_bubbles","_cancelable","Error","initUIEvent","_typeArg","_bubblesArg","_cancelableArg","_viewArg","_detailArg","preventDefault","nativeEvent","Event","stopImmediatePropagation","stopPropagation","FederatedMouseEvent","_super","_this","apply","arguments","client","movement","offset","global","screen","clientX","clientY","getModifierState","key","initMouseEvent","_canBubbleArg","_screenXArg","_screenYArg","_clientXArg","_clientYArg","_ctrlKeyArg","_altKeyArg","_shiftKeyArg","_metaKeyArg","_buttonArg","_relatedTargetArg","FederatedPointerEvent","width","height","isPrimary","getCoalescedEvents","type","getPredictedEvents","FederatedWheelEvent","DOM_DELTA_LINE","DOM_DELTA_PAGE","DOM_DELTA_PIXEL","tempHitLocation","tempLocalMapping","EventBoundary","rootTarget","dispatch","EventEmitter","moveOnAll","mappingState","trackingData","eventPool","Map","hitPruneFn","bind","hitTestFn","mapPointerDown","mapPointerMove","mapPointerOut","mapPointerOver","mapPointerUp","mapPointerUpOutside","mapWheel","mappingTable","addEventMapping","fn","push","priority","sort","a","dispatchEvent","e","propagate","emit","mapEvent","mappers","i","j","console","warn","hitTest","invertedPath","hitTestRecursive","interactive","set","currentTarget","notifyTarget","all","children","parent","reverse","location","testFn","pruneFn","visible","interactiveChildren","child","nestedHit","displayObject","hitArea","worldTransform","applyInverse","contains","_mask","maskObject","isMaskData","containsPoint","_a","call","notifyListeners","from","createPointerEvent","pointerType","isRightButton","button","pointerId","pressTargetsByButton","freeEvent","isMouse","outTarget","findMountedTarget","overTargets","outType","outEvent","includes","leaveEvent","overType","overEvent","clonePointerEvent","overTargetAncestor","enterEvent","propagationMethod","cursor","now","performance","pressTarget","clickTarget","clickEvent","clicksByButton","clickCount","timeStamp","clickHistory","detail","wheelEvent","createWheelEvent","event","allocateEvent","copyPointerData","copyMouseData","copyData","originalEvent","copyWheelData","slice","to","deltaMode","deltaX","deltaY","deltaZ","pressure","tangentialPressure","tiltX","tiltY","twist","altKey","buttons","copyFrom","ctrlKey","metaKey","isTrusted","srcElement","view","which","id","overTarget","has","pop","listeners","_events","context","TOUCH_TO_POINTER","touchstart","touchend","touchendoutside","touchmove","touchcancel","EventSystem","renderer","supportsTouchEvents","globalThis","supportsPointerEvents","PointerEvent","resolution","plugins","interaction","rootBoundary","autoPreventDefault","eventsAdded","rootPointerEvent","rootWheelEvent","cursorStyles","default","pointer","domElement","onPointerDown","onPointerMove","onPointerUp","onPointerOverOut","onWheel","setTargetElement","destroy","setCursor","mode","applyStyles","OffscreenCanvas","currentCursor","style","assign","_lastObjectRendered","events","normalizeToPointerData","isNormalized","nativeEvent_1","federatedEvent","bootstrapEvent","normalizedEvents","outside","normalizeWheelEvent","element","removeEvents","addEvents","navigator","msPointerEnabled","msContentZooming","msTouchAction","touchAction","document","addEventListener","passive","capture","removeEventListener","mapPositionToPoint","point","rect","parentElement","getBoundingClientRect","left","top","resolutionMultiplier","TouchEvent","li","changedTouches","touch","touches","radiusX","radiusY","identifier","force","layerX","offsetX","layerY","offsetY","MouseEvent","tempEvent","transferMouseData","startsWith","replace","movementX","movementY","pageX","pageY","relatedTarget","shiftKey","FederatedDisplayObject","listener","options","undefined","handleEvent","on","off","DisplayObject","mixin"],"mappings":"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"}