{"version":3,"file":"basis.min.mjs","sources":["../../../../node_modules/tslib/tslib.es6.js","../../src/Basis.ts","../../src/TranscoderWorkerWrapper.ts","../../src/TranscoderWorker.ts","../../src/BasisParser.ts","../../src/BasisLoader.ts","../../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { TYPES } from '@pixi/constants';\nimport { INTERNAL_FORMATS } from '@pixi/compressed-textures';\n\n/**\n * The transcoding formats provided by basis_universal.\n *\n * NOTE: Not all of these formats are supported on WebGL!\n * @ignore\n */\n/* eslint-disable camelcase, @typescript-eslint/indent */\nexport enum BASIS_FORMATS\n{\n    cTFETC1 = 0,\n    cTFETC2 = 1,\n    cTFBC1 = 2,\n    cTFBC3 = 3,\n    cTFBC4 = 4,\n    cTFBC5 = 5,\n    cTFBC7 = 6,\n    cTFPVRTC1_4_RGB = 8,\n    cTFPVRTC1_4_RGBA = 9,\n    cTFASTC_4x4 = 10,\n    cTFATC_RGB = 11,\n    cTFATC_RGBA_INTERPOLATED_ALPHA = 12,\n    cTFRGBA32 = 13,\n    cTFRGB565 = 14,\n    cTFBGR565 = 15,\n    cTFRGBA4444 = 16,\n}\n/* eslint-enable camelcase, @typescript-eslint/indent */\n\n/**\n * Maps {@link BASIS_FORMATS} to {@link PIXI.INTERNAL_FORMATS}\n * @ignore\n */\nexport const BASIS_FORMAT_TO_INTERNAL_FORMAT: { [id: number]: INTERNAL_FORMATS } = {\n    [BASIS_FORMATS.cTFETC1]: INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL,\n    [BASIS_FORMATS.cTFBC1]: INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n    [BASIS_FORMATS.cTFBC3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGB]: INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGBA]: INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n    [BASIS_FORMATS.cTFATC_RGB]: INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL,\n    [BASIS_FORMATS.cTFASTC_4x4]: INTERNAL_FORMATS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n};\n\n/**\n * Maps {@link BASIS_FORMATS} to {@link PIXI.TYPES}. These formats are a fallback when the basis file cannot be transcoded\n * to a valid compressed texture format.\n *\n * NOTE: {@link BASIS_FORMATS.cTFBGR565} is not supported, while {@link BASIS_FORMATS.cTFRGBA4444} is not implemented by\n *  [at]pixi/basis.\n * @ignore\n */\nexport const BASIS_FORMAT_TO_TYPE: { [id: number]: TYPES } = {\n    [BASIS_FORMATS.cTFRGBA32]: TYPES.UNSIGNED_BYTE,\n    [BASIS_FORMATS.cTFRGB565]: TYPES.UNSIGNED_SHORT_5_6_5,\n    [BASIS_FORMATS.cTFRGBA4444]: TYPES.UNSIGNED_SHORT_4_4_4_4,\n};\n\n/**\n * Maps {@link PIXI.INTERNAL_FORMATS} to {@link BASIS_FORMATS}\n * @ignore\n */\nexport const INTERNAL_FORMAT_TO_BASIS_FORMAT: { [id: number]: number }\n    = (Object.keys(BASIS_FORMAT_TO_INTERNAL_FORMAT) as string[])\n        .map((key: string) => Number(key))\n        .reduce((reverseMap: any, basisFormat: any) =>\n        {\n            reverseMap[(BASIS_FORMAT_TO_INTERNAL_FORMAT as any)[basisFormat]] = basisFormat;\n\n            return reverseMap;\n        }, {});\n\n/**\n * Enumerates the basis formats with alpha components\n * @ignore\n */\nexport const BASIS_FORMATS_ALPHA: { [id: number]: boolean } = {\n    [BASIS_FORMATS.cTFBC3]: true,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGBA]: true,\n    [BASIS_FORMATS.cTFASTC_4x4]: true,\n};\n\n/**\n * Binding to C++ {@code BasisFile} wrapper class.\n * @see https://github.com/BinomialLLC/basis_universal/blob/master/webgl/transcoder/basis_wrappers.cpp\n * @private\n */\nexport declare class BasisFile\n{\n    constructor(buffer: Uint8Array);\n    getNumImages(): number;\n    getNumLevels(imageId: number): number;\n    getImageWidth(imageId: number, level: number): number;\n    getImageHeight(imageId: number, level: number): number;\n    getHasAlpha(): boolean;\n    startTranscoding(): boolean;\n    getImageTranscodedSizeInBytes(\n        imageId: number,\n        level: number,\n        basisFormat: number): number;\n    transcodeImage(dstBuff: Uint8Array,\n        imageId: number,\n        level: number,\n        basisFormat: BASIS_FORMATS,\n        pvrtcWrapAddressing: boolean,\n        getAlphaForOpaqueFormats: boolean): number;\n    close(): void;\n    delete(): void;\n}\n\n// Missing typings? - https://github.com/microsoft/TypeScript/issues/39655\n/**\n * Compressed texture extensions relevant to the formats into which Basis can decompress into.\n * @ignore\n */\n/* eslint-disable camelcase */\nexport type BasisTextureExtensions = {\n    s3tc?: WEBGL_compressed_texture_s3tc,\n    s3tc_sRGB: WEBGL_compressed_texture_s3tc_srgb,\n    etc: any,\n    etc1: any,\n    pvrtc: any,\n    atc: any,\n    astc: WEBGL_compressed_texture_astc\n};\n/* eslint-enable camelcase */\n\n/**\n * API provided by basis_universal WebGL library.\n * @ignore\n */\nexport type BasisBinding = {\n    BasisFile: typeof BasisFile,\n    initializeBasis(): void\n};\n\n/**\n * Binding to basis_universal WebGL library.\n * @see https://github.com/BinomialLLC/basis_universal/blob/master/webgl/transcoder/build/basis_transcoder.js\n * @ignore\n */\nexport type BASIS = (opts?: { wasmBinary: ArrayBuffer }) => Promise<BasisBinding>;\n","import type { BASIS, BASIS_FORMATS, BasisBinding } from './Basis';\n\n/**\n * Initialization message sent by the main thread.\n * @ignore\n */\nexport interface IInitializeTranscoderMessage\n{\n    wasmSource: ArrayBuffer;\n    type: 'init';\n}\n\n/**\n * Request parameters for transcoding basis files. It only supports transcoding all of the basis file at once.\n * @ignore\n */\nexport interface ITranscodeMessage\n{\n    requestID?: number;\n    rgbFormat: number;\n    rgbaFormat?: number;\n    basisData?: Uint8Array;\n    type: 'transcode';\n}\n\n/** @ignore */\nexport interface ITranscodedImage\n{\n    imageID: number;\n    levelArray: Array<{\n        levelID: number,\n        levelWidth: number,\n        levelHeight: number,\n        levelBuffer: Uint8Array\n    }>;\n    width: number;\n    height: number;\n}\n\n/**\n * Response format for {@link TranscoderWorker}.\n * @ignore\n */\nexport interface ITranscodeResponse\n{\n    type: 'init' | 'transcode';\n    requestID?: number;\n    success: boolean;\n    basisFormat?: BASIS_FORMATS;\n    imageArray?: Array<{\n        imageID: number,\n        levelArray: Array<{\n            levelID: number,\n            levelWidth: number,\n            levelHeight: number,\n            levelBuffer: Uint8Array\n        }>,\n        width: number,\n        height: number\n    }>;\n}\n\ndeclare global\n{\n    interface Window\n    {\n        BASIS: BASIS;\n    }\n}\n\n/**\n * This wraps the transcoder web-worker functionality; it can be converted into a string to get the source code. It expects\n * you to prepend the transcoder JavaScript code so that the `BASIS` namespace is available.\n *\n * The transcoder worker responds to two types of messages: \"init\" and \"transcode\". You must always send the first \"init\"\n * {@link IInitializeTranscoderMessage} message with the WebAssembly binary; if the transcoder is successfully initialized,\n * the web-worker will respond by sending another {@link ITranscodeResponse} message with `success: true`.\n * @ignore\n */\nexport function TranscoderWorkerWrapper(): void\n{\n    let basisBinding: BasisBinding;\n\n    const messageHandlers = {\n        init: (message: IInitializeTranscoderMessage): ITranscodeResponse =>\n        {\n            if (!self.BASIS)\n            {\n                console.warn('jsSource was not prepended?');\n\n                return {\n                    type: 'init',\n                    success: false\n                };\n            }\n\n            self.BASIS({ wasmBinary: message.wasmSource }).then((basisLibrary) =>\n            {\n                basisLibrary.initializeBasis();\n                basisBinding = basisLibrary;\n\n                (self as any).postMessage({\n                    type: 'init',\n                    success: true\n                });\n            });\n\n            return null;\n        },\n        transcode(message: ITranscodeMessage): ITranscodeResponse\n        {\n            const basisData = message.basisData;\n            const BASIS = basisBinding;\n\n            const data = basisData;\n            const basisFile = new BASIS.BasisFile(data);\n            const imageCount = basisFile.getNumImages();\n            const hasAlpha = basisFile.getHasAlpha();\n\n            const basisFormat = hasAlpha\n                ? message.rgbaFormat\n                : message.rgbFormat;\n            const basisFallbackFormat = 14;// BASIS_FORMATS.cTFRGB565 (cannot import values into web-worker!)\n            const imageArray = new Array(imageCount);\n\n            let fallbackMode = false;\n\n            if (!basisFile.startTranscoding())\n            {\n                basisFile.close();\n                basisFile.delete();\n\n                return {\n                    type: 'transcode',\n                    requestID: message.requestID,\n                    success: false,\n                    imageArray: null\n                };\n            }\n\n            for (let i = 0; i < imageCount; i++)\n            {\n                const levels = basisFile.getNumLevels(i);\n                const imageResource: ITranscodedImage = {\n                    imageID: i,\n                    levelArray: new Array<{\n                        levelID: number,\n                        levelWidth: number,\n                        levelHeight: number,\n                        levelBuffer: Uint8Array\n                    }>(),\n                    width: null,\n                    height: null\n                };\n\n                for (let j = 0; j < levels; j++)\n                {\n                    const format = !fallbackMode ? basisFormat : basisFallbackFormat;\n\n                    const width = basisFile.getImageWidth(i, j);\n                    const height = basisFile.getImageHeight(i, j);\n                    const byteSize = basisFile.getImageTranscodedSizeInBytes(i, j, format);\n\n                    const alignedWidth = (width + 3) & ~3;\n                    const alignedHeight = (height + 3) & ~3;\n\n                    // Level 0 is texture's actual width, height\n                    if (j === 0)\n                    {\n                        imageResource.width = alignedWidth;\n                        imageResource.height = alignedHeight;\n                    }\n\n                    const imageBuffer = new Uint8Array(byteSize);\n\n                    if (!basisFile.transcodeImage(imageBuffer, i, j, format, false, false))\n                    {\n                        if (fallbackMode)\n                        {\n                            // We failed in fallback mode as well!\n                            console.error(`Basis failed to transcode image ${i}, level ${j}!`);\n\n                            return { type: 'transcode', requestID: message.requestID, success: false };\n                        }\n\n                        /* eslint-disable-next-line max-len */\n                        console.warn(`Basis failed to transcode image ${i}, level ${j}! Retrying to an uncompressed texture format!`);\n                        i = -1;\n                        fallbackMode = true;\n\n                        break;\n                    }\n\n                    imageResource.levelArray.push({\n                        levelID: j,\n                        levelWidth: width,\n                        levelHeight: height,\n                        levelBuffer: imageBuffer\n                    });\n                }\n\n                imageArray[i] = imageResource;\n            }\n\n            basisFile.close();\n            basisFile.delete();\n\n            return {\n                type: 'transcode',\n                requestID: message.requestID,\n                success: true,\n                basisFormat: !fallbackMode ? basisFormat : basisFallbackFormat,\n                imageArray\n            };\n        }\n    };\n\n    self.onmessage = (e: { data: Partial<IInitializeTranscoderMessage | ITranscodeMessage> }): void =>\n    {\n        const msg = e.data;\n        const response = messageHandlers[msg.type](msg as any);\n\n        if (response)\n        {\n            (self as any).postMessage(response);\n        }\n    };\n}\n","import type { BASIS_FORMATS } from './Basis';\nimport type { ITranscodeResponse } from './TranscoderWorkerWrapper';\nimport { TranscoderWorkerWrapper } from './TranscoderWorkerWrapper';\n\n/**\n * Worker class for transcoding *.basis files in background threads.\n *\n * To enable asynchronous transcoding, you need to provide the URL to the basis_universal transcoding\n * library.\n * @memberof PIXI.BasisLoader\n */\nexport class TranscoderWorker\n{\n    // IMPLEMENTATION NOTE: TranscoderWorker tracks transcoding requests with a requestID; the worker can be issued\n    // multiple requests (once it is initialized) and the response contains the requestID of the triggering request. Based on\n    // the response, the transcodeAsync promise is fulfilled or rejected.\n\n    // TODO: Publish our own @pixi/basis package & set default URL to jsdelivr/cdnjs\n    /** URL for the script containing the basis_universal library. */\n    static bindingURL: string;\n    static jsSource: string;\n    static wasmSource: ArrayBuffer;\n\n    private static _onTranscoderInitializedResolve: () => void;\n\n    /** a promise that when reslved means the transcoder is ready to be used */\n    public static onTranscoderInitialized = new Promise<void>((resolve) =>\n    {\n        TranscoderWorker._onTranscoderInitializedResolve = resolve;\n    });\n\n    isInit: boolean;\n    load: number;\n    requests: { [id: number]: {\n        resolve: (data: ITranscodeResponse) => void,\n        reject: () => void\n    } } = {};\n\n    private static _workerURL: string;\n    private static _tempID = 0;\n\n    /** Generated URL for the transcoder worker script. */\n    static get workerURL(): string\n    {\n        if (!TranscoderWorker._workerURL)\n        {\n            let workerSource = TranscoderWorkerWrapper.toString();\n\n            const beginIndex = workerSource.indexOf('{');\n            const endIndex = workerSource.lastIndexOf('}');\n\n            workerSource = workerSource.slice(beginIndex + 1, endIndex);\n\n            if (TranscoderWorker.jsSource)\n            {\n                workerSource = `${TranscoderWorker.jsSource}\\n${workerSource}`;\n            }\n\n            TranscoderWorker._workerURL = URL.createObjectURL(new Blob([workerSource]));\n        }\n\n        return TranscoderWorker._workerURL;\n    }\n\n    protected worker: Worker;\n    protected initPromise: Promise<void>;\n    protected onInit: () => void;\n\n    constructor()\n    {\n        this.isInit = false;\n        this.load = 0;\n        this.initPromise = new Promise((resolve) => { this.onInit = resolve; });\n\n        if (!TranscoderWorker.wasmSource)\n        {\n            console.warn('PIXI.resources.BasisResource.TranscoderWorker has not been given the transcoder WASM binary!');\n        }\n\n        this.worker = new Worker(TranscoderWorker.workerURL);\n        this.worker.onmessage = this.onMessage;\n        this.worker.postMessage({\n            type: 'init',\n            jsSource: TranscoderWorker.jsSource,\n            wasmSource: TranscoderWorker.wasmSource\n        });\n    }\n\n    /** @returns a promise that is resolved when the web-worker is initialized */\n    initAsync(): Promise<void>\n    {\n        return this.initPromise;\n    }\n\n    /**\n     * Creates a promise that will resolve when the transcoding of a *.basis file is complete.\n     * @param basisData - *.basis file contents\n     * @param rgbaFormat - transcoding format for RGBA files\n     * @param rgbFormat - transcoding format for RGB files\n     * @returns a promise that is resolved with the transcoding response of the web-worker\n     */\n    async transcodeAsync(\n        basisData: Uint8Array,\n        rgbaFormat: BASIS_FORMATS,\n        rgbFormat: BASIS_FORMATS\n    ): Promise<ITranscodeResponse>\n    {\n        ++this.load;\n\n        const requestID = TranscoderWorker._tempID++;\n        const requestPromise = new Promise((resolve: (data: ITranscodeResponse) => void, reject: () => void) =>\n        {\n            this.requests[requestID] = {\n                resolve,\n                reject\n            };\n        });\n\n        this.worker.postMessage({\n            requestID,\n            basisData,\n            rgbaFormat,\n            rgbFormat,\n            type: 'transcode'\n        });\n\n        return requestPromise;\n    }\n\n    /**\n     * Handles responses from the web-worker\n     * @param e - a message event containing the transcoded response\n     */\n    protected onMessage = (e: MessageEvent): void =>\n    {\n        const data = e.data as ITranscodeResponse;\n\n        if (data.type === 'init')\n        {\n            if (!data.success)\n            {\n                throw new Error('BasisResource.TranscoderWorker failed to initialize.');\n            }\n\n            this.isInit = true;\n            this.onInit();\n        }\n        else if (data.type === 'transcode')\n        {\n            --this.load;\n\n            const requestID = data.requestID;\n\n            if (data.success)\n            {\n                this.requests[requestID].resolve(data);\n            }\n            else\n            {\n                this.requests[requestID].reject();\n            }\n\n            delete this.requests[requestID];\n        }\n    };\n\n    /**\n     * Loads the transcoder source code\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     * @returns A promise that resolves when both the js and wasm transcoders have been loaded.\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        const jsPromise = fetch(jsURL)\n            .then((res: Response) => res.text())\n            .then((text: string) => { TranscoderWorker.jsSource = text; });\n        const wasmPromise = fetch(wasmURL)\n            .then((res: Response) => res.arrayBuffer())\n            .then((arrayBuffer: ArrayBuffer) => { TranscoderWorker.wasmSource = arrayBuffer; });\n\n        return Promise.all([jsPromise, wasmPromise]).then((data) =>\n\n        {\n            this._onTranscoderInitializedResolve();\n\n            return data;\n        });\n    }\n\n    /**\n     * Set the transcoder source code directly\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        TranscoderWorker.jsSource = jsSource;\n        TranscoderWorker.wasmSource = wasmSource;\n    }\n}\n","import { TYPES } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/core';\nimport { BufferResource, ExtensionType } from '@pixi/core';\nimport { CompressedTextureResource } from '@pixi/compressed-textures';\nimport type {\n    BasisTextureExtensions,\n    BasisBinding } from './Basis';\nimport {\n    BASIS_FORMATS,\n    BASIS_FORMAT_TO_INTERNAL_FORMAT,\n    INTERNAL_FORMAT_TO_BASIS_FORMAT,\n    BASIS_FORMATS_ALPHA\n} from './Basis';\nimport { TranscoderWorker } from './TranscoderWorker';\n\nimport type { CompressedLevelBuffer, INTERNAL_FORMATS } from '@pixi/compressed-textures';\nimport { settings } from '@pixi/settings';\n\nexport type TranscodedResourcesArray = (Array<CompressedTextureResource> | Array<BufferResource>) & {\n    basisFormat: BASIS_FORMATS\n};\n\n/**\n * Loader plugin for handling BASIS supercompressed texture files.\n *\n * To use this loader, you must bind the basis_universal WebAssembly transcoder. There are two ways of\n * doing this:\n *\n * 1. Adding a &lt;script&gt; tag to your HTML page to the transcoder bundle in this package, and serving\n * the WASM binary from the same location.\n *\n * ```js\n * // Copy ./node_modules/@pixi/basis/assets/basis_.wasm into your assets directory\n * // as well, so it is served from the same folder as the JavaScript!\n * &lt;script src=\"./node_modules/@pixi/basis/assets/basis_transcoder.js\" /&gt;\n * ```\n *\n * NOTE: `basis_transcoder.js` expects the WebAssembly binary to be named `basis_transcoder.wasm`.\n * NOTE-2: This method supports transcoding on the main-thread. Only use this if you have 1 or 2 *.basis\n * files.\n *\n * 2. Loading the transcoder source from a URL.\n *\n * ```js\n * // Use this if you to use the default CDN url for @pixi/basis\n * BasisParser.loadTranscoder();\n *\n * // Use this if you want to serve the transcoder on your own\n * BasisParser.loadTranscoder('./basis_transcoder.js', './basis_transcoder.wasm');\n * ```\n *\n * NOTE: This can only be used with web-workers.\n * @class\n * @memberof PIXI\n * @implements {PIXI.ILoaderPlugin}\n */\nexport class BasisParser\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = ExtensionType.Loader;\n\n    public static basisBinding: BasisBinding;\n    private static defaultRGBFormat: { basisFormat: BASIS_FORMATS, textureFormat: INTERNAL_FORMATS | TYPES };\n    private static defaultRGBAFormat: { basisFormat: BASIS_FORMATS, textureFormat: INTERNAL_FORMATS | TYPES };\n    private static fallbackMode = false;\n    private static workerPool: TranscoderWorker[] = [];\n\n    /**\n     * Runs transcoding and populates {@link imageArray}. It will run the transcoding in a web worker\n     * if they are available.\n     * @private\n     */\n    public static async transcode(arrayBuffer: ArrayBuffer): Promise<TranscodedResourcesArray>\n    {\n        let resources: TranscodedResourcesArray;\n\n        if (typeof Worker !== 'undefined' && BasisParser.TranscoderWorker.wasmSource)\n        {\n            resources = await BasisParser.transcodeAsync(arrayBuffer);\n        }\n        else\n        {\n            resources = BasisParser.transcodeSync(arrayBuffer);\n        }\n\n        return resources;\n    }\n\n    /**\n     * Finds a suitable worker for transcoding and sends a transcoding request\n     * @private\n     * @async\n     */\n    public static async transcodeAsync(arrayBuffer: ArrayBuffer): Promise<TranscodedResourcesArray>\n    {\n        if (!BasisParser.defaultRGBAFormat && !BasisParser.defaultRGBFormat)\n        {\n            BasisParser.autoDetectFormats();\n        }\n\n        const workerPool = BasisParser.workerPool;\n\n        let leastLoad = 0x10000000;\n        let worker = null;\n\n        for (let i = 0, j = workerPool.length; i < j; i++)\n        {\n            if (workerPool[i].load < leastLoad)\n            {\n                worker = workerPool[i];\n                leastLoad = worker.load;\n            }\n        }\n\n        if (!worker)\n        {\n            /* eslint-disable-next-line no-use-before-define */\n            worker = new TranscoderWorker();\n\n            workerPool.push(worker);\n        }\n\n        // Wait until worker is ready\n        await worker.initAsync();\n\n        const response = await worker.transcodeAsync(\n            new Uint8Array(arrayBuffer),\n            BasisParser.defaultRGBAFormat.basisFormat,\n            BasisParser.defaultRGBFormat.basisFormat,\n        );\n\n        const basisFormat = response.basisFormat;\n        const imageArray = response.imageArray;\n\n        // whether it is an uncompressed format\n        const fallbackMode = basisFormat > 12;\n        let imageResources: TranscodedResourcesArray;\n\n        if (!fallbackMode)\n        {\n            const format = BASIS_FORMAT_TO_INTERNAL_FORMAT[response.basisFormat];\n\n            // HINT: this.imageArray is CompressedTextureResource[]\n            imageResources = new Array<CompressedTextureResource>(imageArray.length) as TranscodedResourcesArray;\n\n            for (let i = 0, j = imageArray.length; i < j; i++)\n            {\n                imageResources[i] = new CompressedTextureResource(null, {\n                    format,\n                    width: imageArray[i].width,\n                    height: imageArray[i].height,\n                    levelBuffers: imageArray[i].levelArray,\n                    levels: imageArray[i].levelArray.length,\n                });\n            }\n        }\n        else\n        {\n            // TODO: BufferResource does not support manual mipmapping.\n            imageResources = imageArray.map((image) => new BufferResource(\n                new Uint16Array(image.levelArray[0].levelBuffer.buffer), {\n                    width: image.width,\n                    height: image.height,\n                }),\n            ) as TranscodedResourcesArray;\n        }\n\n        imageResources.basisFormat = basisFormat;\n\n        return imageResources;\n    }\n\n    /**\n     * Runs transcoding on the main thread.\n     * @private\n     */\n    public static transcodeSync(arrayBuffer: ArrayBuffer): TranscodedResourcesArray\n    {\n        if (!BasisParser.defaultRGBAFormat && !BasisParser.defaultRGBFormat)\n        {\n            BasisParser.autoDetectFormats();\n        }\n\n        const BASIS = BasisParser.basisBinding;\n\n        const data = new Uint8Array(arrayBuffer);\n        const basisFile = new BASIS.BasisFile(data);\n        const imageCount = basisFile.getNumImages();\n        const hasAlpha = basisFile.getHasAlpha();\n\n        const basisFormat = hasAlpha\n            ? BasisParser.defaultRGBAFormat.basisFormat\n            : BasisParser.defaultRGBFormat.basisFormat;\n        const basisFallbackFormat = BASIS_FORMATS.cTFRGB565;\n        const imageResources = new Array<CompressedTextureResource | BufferResource>(imageCount);\n\n        let fallbackMode = BasisParser.fallbackMode;\n\n        if (!basisFile.startTranscoding())\n        {\n            // #if _DEBUG\n            console.error(`Basis failed to start transcoding!`);\n            // #endif\n\n            basisFile.close();\n            basisFile.delete();\n\n            return null;\n        }\n\n        for (let i = 0; i < imageCount; i++)\n        {\n            // Don't transcode all mipmap levels in fallback mode!\n            const levels = !fallbackMode ? basisFile.getNumLevels(i) : 1;\n            const width = basisFile.getImageWidth(i, 0);\n            const height = basisFile.getImageHeight(i, 0);\n            const alignedWidth = (width + 3) & ~3;\n            const alignedHeight = (height + 3) & ~3;\n\n            const imageLevels = new Array<CompressedLevelBuffer>(levels);\n\n            // Transcode mipmap levels into \"imageLevels\"\n            for (let j = 0; j < levels; j++)\n            {\n                const levelWidth = basisFile.getImageWidth(i, j);\n                const levelHeight = basisFile.getImageHeight(i, j);\n                const byteSize = basisFile.getImageTranscodedSizeInBytes(\n                    i, 0, !fallbackMode ? basisFormat : basisFallbackFormat);\n\n                imageLevels[j] = {\n                    levelID: j,\n                    levelBuffer: new Uint8Array(byteSize),\n                    levelWidth,\n                    levelHeight,\n                };\n\n                if (!basisFile.transcodeImage(\n                    imageLevels[j].levelBuffer, i, 0, !fallbackMode ? basisFormat : basisFallbackFormat, false, false))\n                {\n                    if (fallbackMode)\n                    {\n                        // #if _DEBUG\n                        console.error(`Basis failed to transcode image ${i}, level ${0}!`);\n                        // #endif\n                        break;\n                    }\n                    else\n                    {\n                        // Try transcoding to an uncompressed format before giving up!\n                        // NOTE: We must start all over again as all Resources must be in compressed OR uncompressed.\n                        i = -1;\n                        fallbackMode = true;\n\n                        // #if _DEBUG\n                        /* eslint-disable-next-line max-len */\n                        console.warn(`Basis failed to transcode image ${i}, level ${0} to a compressed texture format. Retrying to an uncompressed fallback format!`);\n                        // #endif\n                        continue;\n                    }\n                }\n            }\n\n            let imageResource;\n\n            if (!fallbackMode)\n            {\n                imageResource = new CompressedTextureResource(null, {\n                    format: BASIS_FORMAT_TO_INTERNAL_FORMAT[basisFormat],\n                    width: alignedWidth,\n                    height: alignedHeight,\n                    levelBuffers: imageLevels,\n                    levels,\n                });\n            }\n            else\n            {\n                // TODO: BufferResource doesn't support manual mipmap levels\n                imageResource = new BufferResource(\n                    new Uint16Array(imageLevels[0].levelBuffer.buffer), { width, height });\n            }\n\n            imageResources[i] = imageResource;\n        }\n\n        basisFile.close();\n        basisFile.delete();\n\n        const transcodedResources = imageResources as TranscodedResourcesArray;\n\n        transcodedResources.basisFormat = !fallbackMode ? basisFormat : basisFallbackFormat;\n\n        return transcodedResources;\n    }\n\n    /**\n     * Detects the available compressed texture formats on the device.\n     * @param extensions - extensions provided by a WebGL context\n     * @ignore\n     */\n    static autoDetectFormats(extensions?: Partial<BasisTextureExtensions>): void\n    {\n        // Auto-detect WebGL compressed-texture extensions\n        if (!extensions)\n        {\n            const canvas = settings.ADAPTER.createCanvas();\n            const gl = canvas.getContext('webgl');\n\n            if (!gl)\n            {\n                console.error('WebGL not available for BASIS transcoding. Silently failing.');\n\n                return;\n            }\n\n            extensions = {\n                s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n                s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), /* eslint-disable-line camelcase */\n                astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n                etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n                etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n                pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                    || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n                atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n            };\n        }\n\n        // Discover the available texture formats\n        const supportedFormats: { [id: string]: INTERNAL_FORMATS } = {};\n\n        for (const key in extensions)\n        {\n            const extension = (extensions as any)[key];\n\n            if (!extension)\n            {\n                continue;\n            }\n\n            Object.assign(supportedFormats, Object.getPrototypeOf(extension));\n        }\n\n        // Set the default alpha/non-alpha output formats for basisu transcoding\n        for (let i = 0; i < 2; i++)\n        {\n            const detectWithAlpha = !!i;\n            let internalFormat: number;\n            let basisFormat: number;\n\n            for (const id in supportedFormats)\n            {\n                internalFormat = supportedFormats[id];\n                basisFormat = INTERNAL_FORMAT_TO_BASIS_FORMAT[internalFormat];\n\n                if (basisFormat !== undefined)\n                {\n                    if ((detectWithAlpha && BASIS_FORMATS_ALPHA[basisFormat])\n                        || (!detectWithAlpha && !BASIS_FORMATS_ALPHA[basisFormat]))\n                    {\n                        break;\n                    }\n                }\n            }\n\n            if (internalFormat)\n            {\n                BasisParser[detectWithAlpha ? 'defaultRGBAFormat' : 'defaultRGBFormat'] = {\n                    textureFormat: internalFormat,\n                    basisFormat,\n                };\n            }\n            else\n            {\n                BasisParser[detectWithAlpha ? 'defaultRGBAFormat' : 'defaultRGBFormat'] = {\n                    textureFormat: TYPES.UNSIGNED_SHORT_5_6_5,\n                    basisFormat: BASIS_FORMATS.cTFRGB565,\n                };\n\n                BasisParser.fallbackMode = true;\n            }\n        }\n    }\n\n    /**\n     * Binds the basis_universal transcoder to decompress *.basis files. You must initialize the transcoder library yourself.\n     *\n     * ```js\n     * import { BasisParser } from '@pixi/basis';\n     * import { Loader } from '@pixi/loaders';\n     *\n     * // window.BASIS() returns a Promise-like object\n     * window.BASIS().then((basisLibrary) =>\n     * {\n     *     // Initialize basis-library; otherwise, transcoded results maybe corrupt!\n     *     basisLibrary.initializeBasis();\n     *\n     *     // Bind BasisParser to the transcoder\n     *     BasisParser.bindTranscoder(basisLibrary);\n     * });\n     * ```\n     * @param basisLibrary - the initialized transcoder library\n     * @private\n     */\n    static bindTranscoder(basisLibrary: BasisBinding): void\n    {\n        BasisParser.basisBinding = basisLibrary;\n    }\n\n    /**\n     * Loads the transcoder source code for use in {@link PIXI.BasisParser.TranscoderWorker}.\n     * @private\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        return BasisParser.TranscoderWorker.loadTranscoder(jsURL, wasmURL);\n    }\n\n    /**\n     * Set the transcoder source code directly\n     * @private\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        BasisParser.TranscoderWorker.setTranscoder(jsSource, wasmSource);\n    }\n\n    static TranscoderWorker: typeof TranscoderWorker = TranscoderWorker;\n\n    static get TRANSCODER_WORKER_POOL_LIMIT(): number\n    {\n        return this.workerPool.length || 1;\n    }\n\n    static set TRANSCODER_WORKER_POOL_LIMIT(limit: number)\n    {\n        // TODO: Destroy workers?\n        for (let i = this.workerPool.length; i < limit; i++)\n        {\n            this.workerPool[i] = new TranscoderWorker();\n            this.workerPool[i].initAsync();\n        }\n    }\n}\n","import type { TYPES } from '@pixi/constants';\nimport { MIPMAP_MODES, ALPHA_MODES, FORMATS } from '@pixi/constants';\nimport type { BufferResource, ExtensionMetadata } from '@pixi/core';\nimport { BaseTexture, ExtensionType, Texture } from '@pixi/core';\nimport { CompressedTextureResource } from '@pixi/compressed-textures';\nimport type {\n    BasisBinding } from './Basis';\nimport {\n    BASIS_FORMATS,\n    BASIS_FORMAT_TO_TYPE,\n} from './Basis';\nimport { TranscoderWorker } from './TranscoderWorker';\nimport { LoaderResource } from '@pixi/loaders';\n\nimport type { IResourceMetadata } from '@pixi/loaders';\nimport type { TranscodedResourcesArray } from './BasisParser';\nimport { BasisParser } from './BasisParser';\n\n/**\n * Result when calling registerCompressedTextures.\n * @ignore\n */\n type BasisTexturesResult = Pick<LoaderResource, 'textures' | 'texture'>;\n\nLoaderResource.setExtensionXhrType('basis', LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\n\n/**\n * Loader plugin for handling BASIS supercompressed texture files.\n *\n * To use this loader, you must bind the basis_universal WebAssembly transcoder. There are two ways of\n * doing this:\n *\n * 1. Adding a &lt;script&gt; tag to your HTML page to the transcoder bundle in this package, and serving\n * the WASM binary from the same location.\n *\n * ```js\n * // Copy ./node_modules/@pixi/basis/assets/basis_.wasm into your assets directory\n * // as well, so it is served from the same folder as the JavaScript!\n * &lt;script src=\"./node_modules/@pixi/basis/assets/basis_transcoder.js\" /&gt;\n * ```\n *\n * NOTE: `basis_transcoder.js` expects the WebAssembly binary to be named `basis_transcoder.wasm`.\n * NOTE-2: This method supports transcoding on the main-thread. Only use this if you have 1 or 2 *.basis\n * files.\n *\n * 2. Loading the transcoder source from a URL.\n *\n * ```js\n * // Use this if you to use the default CDN url for @pixi/basis\n * BasisLoader.loadTranscoder();\n *\n * // Use this if you want to serve the transcoder on your own\n * BasisLoader.loadTranscoder('./basis_transcoder.js', './basis_transcoder.wasm');\n * ```\n *\n * NOTE: This can only be used with web-workers.\n * @class\n * @memberof PIXI\n * @implements {PIXI.ILoaderPlugin}\n */\nexport class BasisLoader\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = ExtensionType.Loader;\n\n    /**\n     * Transcodes the *.basis data when the data is loaded. If the transcoder is not bound yet, it\n     * will hook transcoding to {@link BasisResource#onTranscoderInitialized}.\n     * @see PIXI.Loader.loaderMiddleware\n     * @param resource - loader resource that is checked to see if it is a basis file\n     * @param next - callback Function to call when done\n     */\n    public static use(resource: LoaderResource, next: (...args: any[]) => void): void\n    {\n        if (resource.extension === 'basis' && resource.data)\n        {\n            (async () =>\n            {\n                if (!BasisParser.basisBinding && (!BasisParser.TranscoderWorker.wasmSource))\n                {\n                    await TranscoderWorker.onTranscoderInitialized;\n                }\n\n                const resources = await BasisParser.transcode(resource.data);\n\n                Object.assign(resource, BasisLoader.registerTextures(\n                    resource.url,\n                    resources,\n                    resource.metadata,\n                ));\n\n                next();\n            })();\n        }\n        else\n        {\n            next();\n        }\n    }\n\n    /**\n     * Creates textures and adds them to the texture cache\n     * @private\n     * @param url - url of the texture to be used as its ID for the texture cache\n     * @param resources - the transcoded resources\n     * @param metadata - resource metadata\n     */\n    private static registerTextures(\n        url: string,\n        resources: TranscodedResourcesArray,\n        metadata: IResourceMetadata,\n    ): BasisTexturesResult\n    {\n        const result: BasisTexturesResult = {\n            textures: {},\n            texture: null,\n        };\n\n        if (!resources)\n        {\n            return result;\n        }\n\n        // Should be a valid TYPES, FORMATS for uncompressed basis formats\n        const type: TYPES = BASIS_FORMAT_TO_TYPE[resources.basisFormat];\n        const format: FORMATS = resources.basisFormat !== BASIS_FORMATS.cTFRGBA32 ? FORMATS.RGB : FORMATS.RGBA;\n        const resourceList = resources as Array<CompressedTextureResource | BufferResource>;\n\n        const textures = resourceList.map((resource) =>\n            (\n                new Texture(new BaseTexture(resource, Object.assign({\n                    mipmap: resource instanceof CompressedTextureResource && resource.levels > 1\n                        ? MIPMAP_MODES.ON_MANUAL\n                        : MIPMAP_MODES.OFF,\n                    alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n                    type,\n                    format,\n                }, metadata)))\n            ));\n\n        textures.forEach((texture: Texture, i: number) =>\n        {\n            const { baseTexture } = texture;\n            const cacheID = `${url}-${i + 1}`;\n\n            BaseTexture.addToCache(baseTexture, cacheID);\n            Texture.addToCache(texture, cacheID);\n\n            if (i === 0)\n            {\n                BaseTexture.addToCache(baseTexture, url);\n                Texture.addToCache(texture, url);\n                result.texture = texture;\n            }\n\n            result.textures[cacheID] = texture;\n        });\n\n        return result;\n    }\n\n    /**\n     * Binds the basis_universal transcoder to decompress *.basis files. You must initialize the transcoder library yourself.\n     *\n     * ```js\n     * import { BasisLoader } from '@pixi/basis';\n     * import { Loader } from '@pixi/loaders';\n     *\n     * // window.BASIS() returns a Promise-like object\n     * window.BASIS().then((basisLibrary) =>\n     * {\n     *     // Initialize basis-library; otherwise, transcoded results maybe corrupt!\n     *     basisLibrary.initializeBasis();\n     *\n     *     // Bind BasisLoader to the transcoder\n     *     BasisLoader.bindTranscoder(basisLibrary);\n     * });\n     * ```\n     * @param basisLibrary - the initialized transcoder library\n     * @private\n     */\n    static bindTranscoder(basisLibrary: BasisBinding): void\n    {\n        BasisParser.basisBinding = basisLibrary;\n    }\n\n    /**\n     * Loads the transcoder source code for use in {@link PIXI.BasisLoader.TranscoderWorker}.\n     * @private\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        return BasisParser.TranscoderWorker.loadTranscoder(jsURL, wasmURL);\n    }\n\n    /**\n     * Set the transcoder source code directly\n     * @private\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        BasisParser.TranscoderWorker.setTranscoder(jsSource, wasmSource);\n    }\n}\n\n","import { extensions } from '@pixi/core';\nimport { BasisLoader } from './BasisLoader';\n\nexport * from './Basis';\nexport * from './BasisLoader';\nexport * from './BasisParser';\nexport * from './TranscoderWorker';\n\nextensions.add(BasisLoader);\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","pop","length","push","BASIS_FORMATS","BASIS_FORMAT_TO_INTERNAL_FORMAT","_a","cTFETC1","INTERNAL_FORMATS","COMPRESSED_RGB_ETC1_WEBGL","cTFBC1","COMPRESSED_RGB_S3TC_DXT1_EXT","cTFBC3","COMPRESSED_RGBA_S3TC_DXT5_EXT","cTFPVRTC1_4_RGB","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","cTFPVRTC1_4_RGBA","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","cTFATC_RGB","COMPRESSED_RGB_ATC_WEBGL","cTFASTC_4x4","COMPRESSED_RGBA_ASTC_4x4_KHR","BASIS_FORMAT_TO_TYPE","_b","cTFRGBA32","TYPES","UNSIGNED_BYTE","cTFRGB565","UNSIGNED_SHORT_5_6_5","cTFRGBA4444","UNSIGNED_SHORT_4_4_4_4","INTERNAL_FORMAT_TO_BASIS_FORMAT","Object","keys","map","key","Number","reduce","reverseMap","basisFormat","BASIS_FORMATS_ALPHA","_c","TranscoderWorkerWrapper","basisBinding","messageHandlers","init","message","self","BASIS","wasmBinary","wasmSource","basisLibrary","initializeBasis","postMessage","type","success","console","warn","transcode","data","basisData","basisFile","BasisFile","imageCount","getNumImages","getHasAlpha","rgbaFormat","rgbFormat","imageArray","Array","fallbackMode","startTranscoding","close","delete","requestID","i","levels","getNumLevels","imageResource","imageID","levelArray","width","height","j","format","getImageWidth","getImageHeight","byteSize","getImageTranscodedSizeInBytes","alignedWidth","alignedHeight","imageBuffer","Uint8Array","transcodeImage","error","levelID","levelWidth","levelHeight","levelBuffer","onmessage","msg","response","TranscoderWorker","_this","requests","onMessage","Error","isInit","onInit","load","initPromise","worker","Worker","workerURL","jsSource","defineProperty","get","_workerURL","workerSource","toString","beginIndex","indexOf","endIndex","lastIndexOf","slice","URL","createObjectURL","Blob","prototype","initAsync","transcodeAsync","_tempID","requestPromise","loadTranscoder","jsURL","wasmURL","jsPromise","fetch","res","text","wasmPromise","arrayBuffer","all","_onTranscoderInitializedResolve","setTranscoder","onTranscoderInitialized","BasisParser","resources","transcodeSync","defaultRGBAFormat","defaultRGBFormat","autoDetectFormats","workerPool","leastLoad","imageResources","image","BufferResource","Uint16Array","buffer","CompressedTextureResource","levelBuffers","basisFallbackFormat","imageLevels","transcodedResources","extensions","gl","settings","ADAPTER","createCanvas","getContext","s3tc","getExtension","s3tc_sRGB","astc","etc","etc1","pvrtc","atc","supportedFormats","extension","assign","getPrototypeOf","detectWithAlpha","internalFormat","id","undefined","textureFormat","bindTranscoder","set","limit","ExtensionType","Loader","LoaderResource","setExtensionXhrType","XHR_RESPONSE_TYPE","BUFFER","BasisLoader","use","resource","registerTextures","url","metadata","textures","texture","FORMATS","RGB","RGBA","Texture","BaseTexture","mipmap","MIPMAP_MODES","ON_MANUAL","OFF","alphaMode","ALPHA_MODES","NO_PREMULTIPLIED_ALPHA","forEach","baseTexture","cacheID","addToCache","add"],"mappings":"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"}